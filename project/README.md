# Old Times Sake
#### Video Demo: https://youtu.be/e66NOC4JJSU
#### Description:
Old Times Sake is a web application designed to help elderly individuals connect with people around them, send friend requests, find activities suitable for their age, send invitations to friends for these activities, and exchange messages. The web application is designed with the elderly in mind, so I tried to make everything as simple as possible to cater to this demographic. The homepage, when the user is logged out, features a navigation bar with the app title, along with “Log In” and “Register” buttons. The header's CSS styling is adapted from a free Start Bootstrap template. Below the header, there’s a section that highlights the application's features with buttons that redirect users to each feature or the “Log In” page if the user is not logged in. Beneath that is the footer.

The “Register” route includes fields for "First Name," "Last Name," "Username," "Birthdate," "Gender," "Country," "City," "Interests," and an option to upload a profile picture. I implemented both client-side and server-side validation to ensure data integrity. The app is only meant for the elderly, so to ensure that every user is at least 50 years old or older, I added a JavaScript function to ensure that the birthdate input shows a date making the user at least 50 years old. Then on the server side, CS50.ai helped with the logic to calculate the user’s age based on their chosen birthdate.

For the country list, I used an API in Javascript to generate the list of countries and enhanced the code further to show them in alphabetical order. For the profile picture, I wanted to control the size of each picture uploaded, store them securely, and serve them fast. For that, I used Cloudinary API. I used a function to control the size and quality and generate a URL for each picture uploaded and stored it in the database.

The “Connect” route allows users to filter and browse other users by city or country. Every user is displayed with a Bootstrap card element, which features the profile picture, name, age, gender, interests, and a "Connect" button. Users can send connection requests if they find someone with shared interests. I used JavaScript to allow the user to dynamically send the request without reloading the page. If the “Connect” button is clicked, it turns into a grey “Sent” button dynamically. If the user reloads the page, they will not see the users that they have sent a connect request to again. The connection is added to the database and will be shown to the recipient’s “Requests” route.

The “Requests” route then shows the user every pending request they have gotten in a Bootstrap card element laid out horizontally with each user’s name, country, city, gender, age, and interests, along with “Accept” and “Reject” buttons. The sender’s info is shown to let the user decide whether to accept or reject the request. If they click accept, the connection gets added to the user’s friends list. If they reject it, they will not see the sender again. In case the user doesn’t have any request, an alert banner will say “You don’t have any requests yet!”

The “Activity” route is the next main feature of the web application. It helps users discover age-appropriate activities in their city. To build this feature, I used Google Places API. The API call takes the user’s country and city as prompts to show the activities in that location. I also wanted to get the accessibility info of each place. For that, I used a second API call from Google Places API (New), which is the next generation of Places API and it shows the accessibility info of each activity.

The API returns a JSON document with information about the place like its name, photo, address, type, etc. It also returns all the activities in that location unfiltered. To filter the activities and show the ones that are suitable for the elderly, I used a nested for loop to go through the “name” and “type” elements in the JSON document and check for certain keywords like "park," "garden," "library," and "museum," etc. Each activity is shown in a Bootstrap card element. The picture of the place is shown on top of the card. Below it, I showed the name of the place, the ratings, the formatted address, the open status, accessibility info, a “View on map” button, and an “Invite” button. The “View on map” shows the user the location of the activity on Google Maps. The user also has the option to invite one or more of their friends to go to this place with them. When the user clicks on the “Invite Friend” button, a modal shows up with all of the user’s friends. They can click on the checkbox next to each friend they want to send the invite to and then click on “Send invite” to send the invites or “Cancel.” In case the user has no friends, an alert banner will show “You have no friends yet.”

The “Invitations” route lists all pending activity invitations in the same card layout as the “Requests” route. Each card shows which user invited them to which activity, with “Accept” and “Reject” buttons. The status of the invitation will be updated in the database based on the button the user clicks on. If the user has no invitations, an alert banner will show “You don’t have any invitations yet!”

The “Notifications” route informs users whether their invitations were accepted or rejected. Notifications appear in horizontally arranged cards, displaying the invitee’s profile picture, name, and whether they accepted or rejected the user’s invitation. If there are no notifications, an alert banner will say “You don’t have any notifications yet!”

The “Friends” route is where the user finds all of their friends. They’re shown in Bootstrap card elements. It has the same layout and the same info shown in the “Connect” route. However, there’s a “Send a Message” button at the bottom of each card that opens a modal to allow the user to send a message to the other user. If the user has no friends, an alert banner will say “You don’t have any friends yet!”

The “Messages” route is where the user gets to see all the messages they’ve received from other users. The cards are laid horizontally and each card has a heading that has the sender’s first name and last name. Then, there’s the body of the message and the timestamp. The end of the card has a “Reply” button that opens a modal and allows the user to reply to the message. I’ve queried the database to show the messages in descending order to show the most recent ones first. In case the user doesn’t have any messages, an alert banner will show “You don’t have any messages yet.”

The “Profile” route shows the user their profile information. It displays their first name, last name, username, profile picture, country, and city. I allowed the user to change their profile picture. The new picture gets uploaded with Cloudinary API, and the database gets updated with the new URL. I also gave the user the option to change their password. If they click on the “Change Password” button, they get redirected to the “Change” route. A “Save Changes” button is located at the bottom of the page in case the user uploads a new profile picture.

The “Change” route is where the user gets to change their password. They get three input fields for the old password, new password, and confirming the new password. Below the input field is a “Change Password” button. If there are no errors with the inputs, the new password will be hashed and updated in the database.

The “Error” route utilizes Jinja placeholders to display customized error messages and codes, based on the specific issue encountered by the user.
